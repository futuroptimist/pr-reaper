name: Close my open PRs

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "dry_run: when true, list what would be closed (no changes)"
        type: boolean
        default: true
      author:
        description: "GitHub username for author: qualifier (blank → uses github.actor)"
        type: string
        default: ""
      org:
        description: "Limit to an org (optional, e.g. democratizedspace)"
        type: string
        default: ""
      title_filter:
        description: "Substring to match in PR title (optional, e.g. Codex)"
        type: string
        default: ""
      delete_branch:
        description: "Delete the PR source branch after closing"
        type: boolean
        default: false
      limit:
        description: "Max PRs to process (1–1000)"
        type: number
        default: 1000
      comment:
        description: "Closing comment"
        type: string
        default: "Closing as superseded by a newer Codex run."

permissions:
  contents: read
  pull-requests: write

jobs:
  reap:
    runs-on: ubuntu-latest
    # Prefer a user PAT if provided. If PR_REAPER_TOKEN is not set, gh will likely use GITHUB_TOKEN (repo-scoped) or be unauthenticated.
    env:
      GH_TOKEN: ${{ secrets.PR_REAPER_TOKEN }}
    steps:
      - name: Show auth identity
        run: |
          set -euo pipefail
          echo "gh version:"; gh --version | head -n1 || true
          echo "gh auth status:"; gh auth status || true

          echo "gh api user (login):"
          LOGIN="$(gh api user --jq .login 2>/dev/null || true)"
          echo "${LOGIN:-"(none)"}"

          if [ -z "${GH_TOKEN:-}" ]; then
            echo "::error::GH_TOKEN is not set; add PR_REAPER_TOKEN with repo scope."
            exit 1
          fi
          if [ -z "${LOGIN:-}" ]; then
            echo "::error::gh is unauthenticated; check PR_REAPER_TOKEN."
            exit 1
          fi

          # Case-insensitive header parse; some runners capitalize this header.
          RAW_HEADERS="$(gh api -i user 2>/dev/null | tr -d '\r' || true)"
          SCOPES="$(awk 'BEGIN{IGNORECASE=1} /^x-oauth-scopes:/ {sub(/^x-oauth-scopes:[[:space:]]*/,""); print}' \
            <<< "$RAW_HEADERS")"

          # Fallback: parse scopes from `gh auth status` if header isn’t present.
          if [ -z "${SCOPES:-}" ]; then
            SCOPES="$(gh auth status 2>/dev/null | sed -n 's/.*Token scopes: \(.*\)$/\1/p' | tr -d ,)"
          fi
          SCOPES_TRIM="$(echo "${SCOPES:-}" | xargs || true)"
          echo "token scopes (best-effort): ${SCOPES_TRIM:-"(unknown)"}"

          has_repo=0; has_readorg=0
          grep -Eiq '(^|[[:space:],])repo([[:space:],]|$)' <<< "${SCOPES_TRIM:-}" && has_repo=1 || true
          grep -Eiq '(^|[[:space:],])read:org([[:space:],]|$)' <<< "${SCOPES_TRIM:-}" && has_readorg=1 || true

          ORG_INPUT="${{ github.event.inputs.org }}"
          if [ "$has_repo" -ne 1 ]; then
            echo "::error::GH_TOKEN lacks 'repo' scope; add PR_REAPER_TOKEN with repo scope."
            exit 1
          fi
          if [ -n "$ORG_INPUT" ] && [ "$has_readorg" -ne 1 ]; then
            echo "::error::GH_TOKEN lacks 'read:org' scope required for org searches."
            exit 1
          fi
          if [ "$has_readorg" -ne 1 ]; then
            echo "::warning::Could not verify 'read:org'; org PRs may be skipped."
          fi
      - name: Search PRs
        # Use gh search prs to match results from GitHub UI.
        id: search
        run: |
          AUTHOR="${{ github.event.inputs.author }}"
          if [ -z "$AUTHOR" ]; then
            AUTHOR="${{ github.actor }}"
          fi
          CMD=(gh search prs --author "$AUTHOR" --state open \
            --limit ${{ github.event.inputs.limit }} \
            --json number,repository,title,url)
          if [ -n "${{ github.event.inputs.org }}" ]; then
            CMD+=(--owner "${{ github.event.inputs.org }}")
          fi
          if [ -n "${{ github.event.inputs.title_filter }}" ]; then
            CMD+=(--search "${{ github.event.inputs.title_filter }}" --match title)
          fi
          echo "Search command: ${CMD[*]}"
          "${CMD[@]}" | tee prs.json
          COUNT=$(jq 'length' prs.json)
          echo "Found $COUNT PR(s)"
          echo "count=$COUNT" >> $GITHUB_OUTPUT

      - name: Write summary
        run: |
          COUNT="${{ steps.search.outputs.count }}"
          {
            echo "## pr-reaper summary"
            echo ""
            if [ "$COUNT" = "0" ]; then
              echo "No open PRs found."
            else
              echo "Found **$COUNT** open PR(s):"
              echo ""
              jq -r '
                .[] |
                "- [\(.title)](\(.url))  (\(.repository.nameWithOwner)#\(.number))"
              ' prs.json
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Dry-run listing
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          jq -r '.[] | "\(.url) — \(.title)"' prs.json

      - name: Close PRs
        if: ${{ github.event.inputs.dry_run != 'true' && steps.search.outputs.count != '0' }}
        run: |
          TOTAL="${{ steps.search.outputs.count }}"
          DELETE_FLAG=""
          if [ "${{ github.event.inputs.delete_branch }}" = "true" ]; then
            DELETE_FLAG="--delete-branch"
          fi
          COMMENT="${{ github.event.inputs.comment }}"
          INDEX=0
          while IFS=$'\t' read -r NUM REPO; do
              INDEX=$((INDEX + 1))
              PCT=$(awk -v i="$INDEX" -v total="$TOTAL" 'BEGIN { printf "%.1f", (i / total) * 100 }')
              echo "[${INDEX}/${TOTAL} - ${PCT}%] Closing ${REPO}#${NUM}"
              CMD=(gh pr close "$NUM" --repo "$REPO" --comment "$COMMENT")
              if [ -n "$DELETE_FLAG" ]; then
                CMD+=("$DELETE_FLAG")
              fi
              echo "${CMD[*]}"
              "${CMD[@]}"
            done < <(jq -r '.[] | "\(.number)\t\(.repository.nameWithOwner)"' prs.json)
