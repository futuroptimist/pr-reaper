name: Close my open PRs

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: "dry_run: when true, list what would be closed (no changes)"
        type: boolean
        default: true
      author:
        description: "GitHub username for author: qualifier (blank → uses github.actor)"
        type: string
        default: ""
      org:
        description: "Limit to an org (optional, e.g. democratizedspace)"
        type: string
        default: ""
      title_filter:
        description: "Substring to match in PR title (optional, e.g. Codex)"
        type: string
        default: ""
      delete_branch:
        description: "Delete the PR source branch after closing"
        type: boolean
        default: true
      limit:
        description: "Max PRs to process (1–1000)"
        type: string
        default: "1000"
      comment:
        description: "Closing comment"
        type: string
        default: "Closing as superseded by a newer Codex run."
      exclude_urls:
        description: "PR URLs to skip (space/comma/newline separated, optional)"
        type: string
        default: ""

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  reap:
    runs-on: ubuntu-latest
    # Prefer a user PAT if provided; otherwise fall back to the repo-scoped GITHUB_TOKEN.
    env:
      GH_TOKEN: ${{ secrets.PR_REAPER_TOKEN != '' && secrets.PR_REAPER_TOKEN || secrets.GITHUB_TOKEN }}

    steps:
      - name: Show auth identity
        run: |
          set -euo pipefail
          echo "gh version:"; gh --version | head -n1 || true
          echo "gh auth status:"; gh auth status || true
          echo "gh api user (login):"
          LOGIN="$(gh api user --jq .login 2>/dev/null || true)"
          echo "${LOGIN:-"(none)"}"

          if [ -z "${GH_TOKEN:-}" ]; then
            echo "::error::GH_TOKEN is not set; add PR_REAPER_TOKEN with repo scope."
            exit 1
          fi
          if [ -z "${LOGIN:-}" ]; then
            echo "::error::gh is unauthenticated; check PR_REAPER_TOKEN or GITHUB_TOKEN permissions."
            exit 1
          fi

          # Case-insensitive header parse; some runners capitalize this header.
          RAW_HEADERS="$(gh api -i user 2>/dev/null | tr -d '\r' || true)"
          SCOPES="$(awk 'BEGIN{IGNORECASE=1} /^x-oauth-scopes:/ {sub(/^x-oauth-scopes:[[:space:]]*/,""); print}' \
            <<< "$RAW_HEADERS")"
          # Fallback: parse scopes from `gh auth status` if header isn’t present.
          if [ -z "${SCOPES:-}" ]; then
            SCOPES="$(gh auth status 2>/dev/null | sed -n 's/.*Token scopes: \(.*\)$/\1/p' | tr -d ,)"
          fi
          SCOPES_TRIM="$(echo "${SCOPES:-}" | xargs || true)"
          echo "token scopes (best-effort): ${SCOPES_TRIM:-"(unknown)"}"
          has_repo=0; has_readorg=0
          grep -Eiq '(^|[[:space:],])repo([[:space:],]|$)' <<< "${SCOPES_TRIM:-}" && has_repo=1 || true
          grep -Eiq '(^|[[:space:],])read:org([[:space:],]|$)' <<< "${SCOPES_TRIM:-}" && has_readorg=1 || true
          ORG_INPUT="${{ github.event.inputs.org }}"
          if [ "$has_repo" -ne 1 ]; then
            echo "::error::GH_TOKEN lacks 'repo' scope; add PR_REAPER_TOKEN with repo scope."
            exit 1
          fi
          if [ -n "$ORG_INPUT" ] && [ "$has_readorg" -ne 1 ]; then
            echo "::error::GH_TOKEN lacks 'read:org' scope required for org searches."
            exit 1
          fi
          if [ "$has_readorg" -ne 1 ]; then
            echo "::warning::Could not verify 'read:org'; org PRs may be skipped."
          fi

      - name: Search PRs
        # Use gh search prs to match results from GitHub UI.
        id: search
        run: |
          set -euo pipefail
          LIMIT_INPUT="${{ github.event.inputs.limit }}"
          if [ -z "$LIMIT_INPUT" ]; then
            LIMIT_INPUT="1000"
          fi
          case "$LIMIT_INPUT" in
            ''|*[!0-9]*)
              echo "::error::limit must be an integer between 1 and 1000"
              exit 1
              ;;
          esac
          if [ "$LIMIT_INPUT" -lt 1 ] || [ "$LIMIT_INPUT" -gt 1000 ]; then
            echo "::error::limit must be an integer between 1 and 1000"
            exit 1
          fi
          LIMIT="$LIMIT_INPUT"

          AUTHOR="${{ github.event.inputs.author }}"
          if [ -z "$AUTHOR" ]; then
            AUTHOR="${{ github.actor }}"
          fi

          CMD=(gh search prs --author "$AUTHOR" --state open \
               --limit "$LIMIT" \
               --json number,permalink,repository,title,url)
          if [ -n "${{ github.event.inputs.org }}" ]; then
            CMD+=(--owner "${{ github.event.inputs.org }}")
          fi
          if [ -n "${{ github.event.inputs.title_filter }}" ]; then
            CMD+=(--search "${{ github.event.inputs.title_filter }}" --match title)
          fi
          echo "Search command: ${CMD[*]}"
          "${CMD[@]}" | tee prs.json

          EXCLUDE_INPUT="${{ github.event.inputs.exclude_urls }}"
          if [ -n "$EXCLUDE_INPUT" ]; then
            EXCLUDE_INPUT_DATA="$EXCLUDE_INPUT" python3 - <<'PY'
import json
import os
import re
import sys
from urllib.parse import urlparse

RAW_INPUT = os.environ.get('EXCLUDE_INPUT_DATA', '').replace('\r', '\n')
TOKENS = [part.strip() for part in re.split(r'[\s,;|]+', RAW_INPUT) if part.strip()]

if not TOKENS:
    sys.exit(0)

print(f"Excluding {len(TOKENS)} PR reference(s) from input:")
for token in TOKENS:
    print(f"  - {token}")

with open('prs.json', 'r', encoding='utf-8') as prs_file:
    prs = json.load(prs_file)


def normalize_repo(owner, repo, number, extra_hosts=None):
    number_str = str(int(number, 10))
    owner_lower = owner.lower()
    repo_lower = repo.lower()
    owner_repo = f"{owner_lower}/{repo_lower}"
    refs = {
        f"{owner_repo}#{number_str}",
        f"{owner_repo}/pull/{number_str}",
        f"{owner_repo}/pulls/{number_str}",
        f"https://github.com/{owner_repo}/pull/{number_str}",
        f"https://github.com/{owner_repo}/pulls/{number_str}",
        f"https://api.github.com/repos/{owner_repo}/pulls/{number_str}",
    }
    if extra_hosts:
        for host in extra_hosts:
            base = host.rstrip('/')
            refs.add(f"{base}/repos/{owner_repo}/pulls/{number_str}")
    return refs


def parse_owner_repo_number(value):
    text = value.strip()
    if not text:
        return None

    match = re.fullmatch(r'([^/\s]+)/([^#\s]+)#(\d+)', text, flags=re.IGNORECASE)
    if match:
        owner, repo, number = match.groups()
        return owner.lower(), repo.lower(), number

    match = re.fullmatch(r'([^/\s]+)/([^/\s]+)/pulls?/(\d+)', text, flags=re.IGNORECASE)
    if match:
        owner, repo, number = match.groups()
        return owner.lower(), repo.lower(), number

    if '://' in text:
        try:
            parsed = urlparse(text)
        except ValueError:
            return None
        segments = [segment for segment in parsed.path.split('/') if segment]
        if len(segments) >= 4:
            marker = segments[-2].lower()
            number = segments[-1]
            if number.isdigit():
                if marker == 'pull' and len(segments) >= 4:
                    owner, repo = segments[-4], segments[-3]
                    return owner.lower(), repo.lower(), number
                if marker == 'pulls' and len(segments) >= 5:
                    owner, repo = segments[-4], segments[-3]
                    return owner.lower(), repo.lower(), number

    return None


exclude_refs = set()
for token in TOKENS:
    lowered = token.strip().lower()
    if lowered:
        exclude_refs.add(lowered)
    parsed = parse_owner_repo_number(token)
    if parsed:
        owner, repo, number = parsed
        exclude_refs.update(normalize_repo(owner, repo, number))


def pr_references(pr):
    refs = set()
    repo = pr.get('repository', {}).get('nameWithOwner')
    number = pr.get('number')

    if isinstance(number, int):
        number_str = str(number)
    elif isinstance(number, str) and number.strip():
        number_str = str(int(number.strip(), 10))
    else:
        number_str = None

    extra_hosts = set()
    for key in ('url', 'permalink', 'html_url'):
        value = pr.get(key)
        if isinstance(value, str) and value:
            refs.add(value.lower())
            if number_str and repo and '://' in value:
                try:
                    parsed = urlparse(value)
                except ValueError:
                    parsed = None
                if parsed:
                    base = f"{parsed.scheme}://{parsed.netloc}".lower()
                    extra_hosts.add(base)

    if repo and number_str and '/' in repo:
        owner, repo_name = repo.split('/', 1)
        refs.update(normalize_repo(owner, repo_name, number_str, extra_hosts=extra_hosts))

    return refs


remaining = []
skipped = []
for pr in prs:
    refs = pr_references(pr)
    if refs & exclude_refs:
        skipped.append(pr)
    else:
        remaining.append(pr)

with open('prs.json', 'w', encoding='utf-8') as prs_file:
    json.dump(remaining, prs_file)

if skipped:
    print(f"Skipped {len(skipped)} PR(s) that matched the exclusion list:")
    for pr in skipped:
        repo = pr.get('repository', {}).get('nameWithOwner', '(unknown)')
        number = pr.get('number', '?')
        title = pr.get('title', '')
        print(f"  - {repo}#{number} — {title}")
else:
    print('No PRs matched the exclusion list.')
PY
          fi

          COUNT=$(jq 'length' prs.json)
          echo "Found $COUNT PR(s)"
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"

      - name: Write summary
        run: |
          COUNT="${{ steps.search.outputs.count }}"
          {
            echo "## pr-reaper summary"
            echo ""
            if [ "$COUNT" = "0" ]; then
              echo "No open PRs found."
            else
              echo "Found **$COUNT** open PR(s):"
              echo ""
              jq -r '
                .[] |
                "- [\(.title)](\(.url)) (\(.repository.nameWithOwner)#\(.number))"
              ' prs.json
            fi
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Dry-run listing
        if: ${{ github.event.inputs.dry_run == 'true' }}
        run: |
          jq -r '.[] | "\(.url) — \(.title)"' prs.json

      - name: Close PRs
        if: ${{ github.event.inputs.dry_run != 'true' && steps.search.outputs.count != '0' }}
        run: |
          set -euo pipefail
          TOTAL="${{ steps.search.outputs.count }}"
          DELETE_FLAG=""
          if [ "${{ github.event.inputs.delete_branch }}" = "true" ]; then
            DELETE_FLAG="--delete-branch"
          fi
          COMMENT="${{ github.event.inputs.comment }}"
          INDEX=1
          while IFS=$'\t' read -r NUM REPO; do
            PCT=$(awk -v i="$INDEX" -v total="$TOTAL" 'BEGIN { printf "%.1f", (i / total) * 100 }')
            echo "[${INDEX}/${TOTAL} - ${PCT}%] Closing ${REPO}#${NUM}"
            CMD=(gh pr close "$NUM" --repo "$REPO" --comment "$COMMENT")
            if [ -n "$DELETE_FLAG" ]; then
              CMD+=("$DELETE_FLAG")
            fi
            echo "${CMD[*]}"
            "${CMD[@]}"
            INDEX=$((INDEX + 1))
          done < <(jq -r '.[] | "\(.number)\t\(.repository.nameWithOwner)"' prs.json)
